# DispatchingForPeople

## 目录结构

- data：存放csv地图节点的数据集
- src：存放源代码


## 总说明
  我们定义Chromosome类来表示染色体,并定义了calculate_fitness.mutate.crossover和selection函数来分别计算适应度，变异

### 优化点

0. 地图节点的数据
1. 完成多次调度的编码、解码
2. 完善适应度函数，更好地计算个体的适应度    
3. 添加遗传算法算子：不同的交叉策略、变异、置换...
4. 新的停止条件：收敛条件、运行时间限制
5. 优化参数：交叉概率、变异概率、种群大小
6. 算法结合：模拟退火算法...

### 机器人 设计思路

存储起始点，目的点，任务目的序列，当前行驶的任务目的下标，当前任务序列序号

当机器人运输到目的地进行补给后，
- 若有剩余的物资，优先运输到下一个受灾点；
    - 或顺路前往最近最适合的物资补给点 
    - 继续前往下一个受灾点
- 若不足，则返回补给点后，将这个受灾目的点重新进入任务序列。


### 染色体编码


因为补给点的移动是可以根据受灾点的行驶任务进行动态决定的

所以可以排除补给点的编码，仅仅使用受灾点进行染色体编码。

### 版本

main仅仅实现了遗传的框架
main2实现了机器人的拓展和表示
main2-1更改染色体的初始化及表示

增加了物资的表示方式，同时以package为单位进行传输。



### 项目配置文件说明

/src/config.json：

- `RANDOM_MODE`:随机模式。
  - 1 代表完全随机（仅限制地图节点个数），数据导出
  - 2 读取数据运行
  - 3 代表限制补给点和受灾点个数（TODO）
  - 4 代表限制机器人个数（TODO）
  
~~~json
{
  "RANDOM_MODE": 1, // 生成数据的方式
  "NODE_NUMBER": 10, // 节点数量
  "AFFECTED_NUMBER": 7, // 受灾点数量
  "SUPPLE_NUMBER": 3, // 补给点数量
  "ROBOT_NUMBER": 3, // 机器人数量
  "CHROMOSOME_NUMBER": 20, // 染色体方案数
  "CROSSOVER_RATE": 0.8, // 交叉概率
  "MUTATION_RATE": 0.3, // 变异概率
  "MAX_TIME": 10000, // 最长时间 
  "MAX_GENERATION":100, // 最大迭代次数
  "ANXIETY_RATE": 1.1 // 焦虑幂指速率
}
~~~


### 问题

#### 物资细化

1. 每个机器人的运输能力一样吗?
2. 每个机器人是专门运输一种还是多种？
  - 如果是一种。
  ==> 问题 化归
  - 如果是多种。
3. 每次运输量怎么确定？ 
   - 按固定比例装载
   - 还是每次装载一种
   - 还是根据目的地的需求进行装载
   - 还是根据当前补给点进行装载 
4. 每种物资都有一定的单位重量，如何确保尽可能地满载。

为了降低焦虑度，理论上需要优先装载焦虑系数高的，
但是考虑现实，肯定需要同时装载衣物，那么通讯设备是否需要？




### 可吹水的地方

#### 提前计算优先补给点

在计算每个节点的最近补给点时，我们可以按照优先级依次检查节点需要寻找的补给点，直到找到一个物资充足的补给点为止。为了实现这一过程，我们可以将上述代码中的内层循环改为一个 while 循环，并在循环中检查当前的补给点是否在该节点的优先寻找补给点列表中。

具体而言，我们可以先将 least_distance_supple_node_index 初始化为全零二维数组，然后对于每个节点 i，按照优先级依次遍历该节点需要寻找的补给点下标，直到找到一个物资充足的补给点为止。如果找到了充足的补给点，就将其下标存储到 least_distance_supple_node_index[i][j] 中，并终止循环；否则，将下一个补给点的下标作为循环的继续条件，继续遍历。

这种方法可以让我们避免重复计算每个节点的最近补给点，同时也可以方便地实现多个优先级寻找补给点的功能。如果我们需要更新补给点的物资信息，只需要在更新补给点列表的同时更新 supple_node_index 数组即可。


